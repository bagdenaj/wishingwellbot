#replace TOKEN with Telegram Bot API Token
#replace ADMIN_CHAT_ID with your own Chat_id
#you can find the Chat_id by using the /get_me command

from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, PollAnswerHandler, PollHandler, ConversationHandler
from telegram import InputTextMessageContent, ParseMode, Poll, Update, ReplyKeyboardMarkup
import logging
import random
import json

updater = Updater(token='TOKEN', use_context=True)

jobqueue = updater.job_queue
dispatcher = updater.dispatcher

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

#initiating values for conversationhandler states
ADD_WISH_ANSWER = 0
KEY_ANSWER = 1

def load_users():
	with open('users.json', 'r') as user_list:
		users = json.load(user_list)
		return users

def get_user(chat_id):
	user_list = load_users()
	for user in user_list:
		if user['user_chat_id'] == chat_id:
			return user

def write_to_user(current_user, chat_id):
	users = load_users()
	for i in range(len(users)):
		if users[i]['user_chat_id'] == chat_id:
			users[i] = current_user
			with open('users.json', 'w') as user_list:
				json.dump(users, user_list)

def load_key_list():
	with open('key_list.json', 'r') as key_list:
		key_list = json.load(key_list)
		return key_list

def write_to_key_list(data):
	with open('key_list.json', 'w') as key_list:
		json.dump(data, key_list)

def get_lang(chat_id):
	user = get_user(chat_id)
	if user['lang'] == 'eng':
		return 'eng'
	elif user['lang'] == 'ger':
		return 'ger'

def start(update, context):
	text = 	f'''_____ENGLISH VERSION BELOW_____
	Hallo {update.effective_user.mention_html()},
	Hier spricht dein persönlicher wishingwellbot. Möchtest du auf /deutsch oder auf /english fortfahren?
	\n
	Hello {update.effective_user.mention_html()},
	This is your personal wishingwellbot. Do you want to continue in /deutsch or in /english ?.'''
	
	context.bot.send_message(chat_id=update.effective_chat.id, text=text, parse_mode=ParseMode.HTML)
	
	#if user has no profile, create one an save it in the json file
	if not get_user(update.effective_chat.id):
		users = load_users()
		with open('users.json', 'w') as user_list:
			users.append({'user_chat_id': update.effective_chat.id, 'lang': None, 'partner_chat_id': None, 'wish_list': []})
			json.dump(users, user_list)

def english(update, context):
	text = 	f'''Hi {update.effective_user.mention_html()},
	let\'s start our formal introduction. You can use me to write wishes you have concerning your well-beeing and 
	partnership into a wishlist. 

	You should start by connecting (/connect) your profil with your partners. Once you generated a key, show that key to
	your partner. They can then enter that key after the command /key. Alternatively you can enter your partners key after the command
	/key.

	After that you can add wishes (/add_wish) to your wishlist or fulfill a wish of your partner (/grant_a_wish)

	These are the commands:
	/connect - generates a key to connect to your partner
	/key - enter the key generated by your partner here to connect
	/disconnect - deletes the connection to your partner
	/add_wish - adds a wish to your wishlist
	/show_wishlist - displays your wishlist
	/remove_wish - shows you your wishes in a poll
	/grant_a_wish - shows you two random wishes of your partner
	/spent_some_love - help my maker to make me better
	/cancel - cancels /add_wish or /key'''
	
	#create keyboardmarkup buttons and keyboardmarkup
	buttons = [['/connect','/key'],['/add_wish', '/remove_wish'],['/show_wishlist', '/grant_a_wish'],['/cancel', '/help'],['/settings']]
	reply_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard = False)

	context.bot.send_message(update.effective_chat.id, text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)

	#set language to english and save it in the user profile
	user = get_user(update.effective_chat.id)
	user['lang'] = 'eng'
	write_to_user(user, update.effective_chat.id)

def deutsch(update, context):
	#same as /english but with german text
	text = f'''Hi {update.effective_user.mention_html()},
	willkommen beim wishingwellbot. Mein Ziel ist es eure Beziehung glücklicher zu machen.
	Du kannst mich benutzen um Wünsche, die du hast in einer Liste zu speichern. Wenn du einen Wunsch erfüllen möchtest,
	zeige ich dir gern zwei zufällige Wünsche deiner Partnerin oder deines Partners an.

	Beginne damit, dich mit deiner Partnerin oder deinem Partner zu /verbinden. Dazu benötigt ihr beide den @wishingwellbot in
	eurem Telegram Account. Du erhältst einen Schlüssel (sechsstellige Zahl). Die andere Person muss diesen Schlüssel unter dem Befehl
	/schluessel eingeben. Du kannst auch selbst einen Schlüssel eingeben, wenn die andere Person bereits einen Schlüssel erstellt hat.

	Danach kann jede Person für sich selbst Wünsche zur eigenen Wunschliste hinzufügen (/wuensch_dir_was)oder sich Wünsche der anderen Person anzeigen lassen(/wunsch_erfuellen).

	Folgende Befehle gibt es:
	/verbinden - erzeugt einen Schlüssel, um dich mit einer anderen Person zu verbinden
	/schluessel - gib hier den Schlüssel ein, um die Verbindung herzustellen
	/trenne_dich - löscht die Verbindung zur anderen Person
	/wuensch_dir_was - füge einen Wunsch zu deiner Wunschliste hinzu
	/wunschliste - zeigt dir deine Wunschliste
	/wunsch_loeschen - löscht die Wünsche deiner Wahl von deiner Wunschliste
	/wunsch_erfuellen -  erfülle einen Wunsch der anderen Person, es werden dir zwei zufällig angezeigt
	/spende_liebe - hilf meinem Macher mich besser zu machen
	/cancel - beendet die Funktion /wuensch_dir_was oder /schluessel
	'''

	buttons = [['/verbinden','/schluessel'],['/wuensch_dir_was', '/wunsch_loeschen'],['/wunschliste', '/wunsch_erfuellen'],['/cancel', '/hilfe'],['/einstellungen']]

	reply_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard = False)

	context.bot.send_message(update.effective_chat.id, text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)

	user = get_user(update.effective_chat.id)

	user['lang'] = 'ger'

	write_to_user(user, update.effective_chat.id)

def cancel(update, context):
	#cancels the conversations for /key and /add_wish

	#at first the language the user chose is checked and the text is set accordingly
	if get_lang(update.effective_chat.id) == 'eng':
		text = f'Okay then. Maybe another time.'
	elif get_lang(update.effective_chat.id) == 'ger':
		text = f'Alles klar. Vielleicht ein anderes mal.'

	#now the text is send to the user
	context.bot.send_message(chat_id=update.effective_chat.id, text=text)
	return ConversationHandler.END

def wrong_input(update, context):
	#if the user is sending a second command, apart from /cancel, after the conversation started this function is raised and ends the conversation
	if get_lang(update.effective_chat.id) == 'eng':
		text = f'Ups. You sent to many commands. Now I\'m not sure what you wanted to do. What was it again?'
	elif get_lang(update.effective_chat.id) == 'ger':
		text=f'Ups. Jetzt hast du versehentlich mehrere Befehle auf einmal ausgeführt. Versuche es noch einmal.'
	
	context.bot.send_message(chat_id=update.effective_chat.id, text= text)
	return ConversationHandler.END

def add_wish(update, context):
	#starts the conversationhandler to add a wish to the wishlist

	if get_lang(update.effective_chat.id) == 'eng':
		text = f'What wish do you want to add? You can add multiple wishes by writting each wish in a new line.'
	elif get_lang(update.effective_chat.id) == 'ger':
		text = f'Welchen Wunsch möchtest du hinzufügen? Du kannst mehrere Wünsche hinzufügen, indem du jeden Wunsch in eine neue Zeile schreibst.'

	context.bot.send_message(chat_id=update.effective_chat.id, text= text)
	return ADD_WISH_ANSWER

def add_wish_answer(update, context):
	#adds wishes to the wishlist
	#multiple wishes are possible, if each wish is in a new line
	wishes = update.message.text.split('\n')
	user = get_user(update.effective_chat.id)
	answer = ''
	for wish in wishes:
		user['wish_list'].append(wish)
		#text for the reply is created
		if wish != wishes[-1]:
			if get_lang(update.effective_chat.id) == 'eng':
				answer += wish + ' and '
			elif get_lang(update.effective_chat.id) == 'ger':
				answer += wish + ' und '
		else:
			answer += wish

	if get_lang(update.effective_chat.id) == 'eng':
		text = f'{answer} has been added to the wish list.'
	elif get_lang(update.effective_chat.id) == 'ger':
		text = f'{answer} wurde(n) der Wunschliste hinzugefügt.'

	#wishlist is updated, reply send to user and conversation ended
	write_to_user(user, update.effective_chat.id)
	context.bot.send_message(chat_id=update.effective_chat.id, text= text)
	return ConversationHandler.END

def show_wishlist(update, context):
	user = get_user(update.effective_chat.id)
	wish_list = user['wish_list']

	if get_lang(update.effective_chat.id) == 'eng':
		text1 = 'Your wishlist is currently empty. If you want to add a wish type /add_wish'
		text2 = '\n'.join(wish_list)
	elif get_lang(update.effective_chat.id) == 'ger':
		text = 'Du hast gerade keinen Wunsch in deiner Wunschliste. Wenn du einen hinzufügen möchtest, tippe /wuensch_dir_was'
		text2 = '\n'.join(wish_list)

	if len(wish_list) == 0:
		context.bot.send_message(chat_id=update.effective_chat.id, text= text1)
	else:
		context.bot.send_message(chat_id=update.effective_chat.id, text= text2)

def remove_wish(update, context):
	if get_lang(update.effective_chat.id) == 'eng':
		placeholder = 'This is just a placeholder, because a poll needs at least two options. Please don\'t select me.'
		text = 'You can\'t delete a wish since your wishlist is empty.'
		text2 = 'This is your wishlist. Select the wishes you want to remove and press "Vote".'
	elif get_lang(update.effective_chat.id) == 'ger':
		placeholder = 'Das ist nur ein Platzhalter. Eine Umfrage mindestens 2 Optionen braucht. Bitte wähle mich nicht aus.'
		text = 'Du kannst keinen Wunsch löschen, weil deine Wunschliste leer ist.'
		text2 = 'Das ist deine Wunschliste. Wähle die Wünsche aus, die du löschen möchtest und drücke auf "Abstimmen".'

	#first the wishlist is loaded
	user = get_user(update.effective_chat.id)
	wish_list = user['wish_list']

	#now the length of the wishlist is checked
	#since a poll can only contain 10 options a number of sets is calculated
	#each set represents a poll
	#if the poll would contain only one option a placeholder is added
	if len(wish_list) == 0:
		context.bot.send_message(update.effective_chat.id, text)
		return
	elif len(wish_list)%10 == 0:
		n_of_sets = len(wish_list)//10
	else:
		n_of_sets = len(wish_list)//10+1
	for i in range(n_of_sets):
		wishes = wish_list[i*10:i*10+10]
		if len(wish_list) == 1:
			wishes.append(placeholder)
		message = context.bot.send_poll(update.effective_chat.id, text2, wishes, is_anonymous=False, allows_multiple_answers=True)
		#the poll data is saved in the bot to handle when the user takes the poll
		payload = {
			message.poll.id: {
				"wishes": wishes,
				"message_id": message.message_id,
				"chat_id": update.effective_chat.id,
				"answers": 0,
			}
		}
		context.bot_data.update(payload)

def remove_wish_answer(update, context):
	answer = update.poll_answer
	poll_id = answer.poll_id
	chat_id = context.bot_data[poll_id]["chat_id"]

	if get_lang(chat_id) == 'eng':
		text = f"The wish wasn\'t on the list for some reason ;). Or you selected the placeholder!"
	elif get_lang(chat_id) == 'ger':
		text = f"Der Wunsch war aus irgendeinem Grund nicht mehr auf der Liste ;). Oder du hast den Platzhalter ausgewählt!"
	
	#Summarize a users poll vote
	wish_list = get_user(chat_id)['wish_list']
	try:
		wishes = context.bot_data[poll_id]["wishes"]
	#this means this poll answer update is from an old poll, we can't do our answering then
	except KeyError:
		return
	selected_options = answer.option_ids
	answer_string = ""
	removed_wishes = []
	for question_id in selected_options:
		#answerstring is created the same way as in /add_wish_answer
		if question_id != selected_options[-1]:
			if get_lang(chat_id) == 'eng':
				answer_string += wishes[question_id] + " and "
				removed_wishes.append(wishes[question_id])
			elif get_lang(chat_id) == 'ger':
				answer_string += wishes[question_id] + " und "
				removed_wishes.append(wishes[question_id])
		else:
			answer_string += wishes[question_id]
			removed_wishes.append(wishes[question_id])
	
	#if a wish is about to be removed from the list, but isn't there anymore
	#it means the partner granted the wish already, so the user get's a message
	for wish in removed_wishes:
		try:
			wish_list.remove(wish)
		except ValueError:
			context.bot.send_message(
				chat_id,
				text
			)

	if get_lang(chat_id) == 'eng':
		text = f"You removed {answer_string} from your wishlist!"
	elif get_lang(chat_id) == 'ger':
		text = f"Du hast {answer_string} von deiner Wunschliste entfernt!"
	
	context.bot.send_message(
		chat_id,
		text
	)
	context.bot.stop_poll(
		chat_id, context.bot_data[poll_id]["message_id"]
	)

	#overwrite wishlist of current user
	user = get_user(chat_id)
	user['wish_list'] = wish_list
	write_to_user(user, chat_id)

def connect(update, context):
	key = random.randint(100000, 999999)

	if get_lang(update.effective_chat.id) == 'eng':
		text = 'You already generated a key. Please wait for your partner to connect.'
		text2 = f'To connect with your partner please show him or her the key: {key} \n They have to enter \"/key (your key)\" to connect with your profile.'
		text3 = 'You are already connected to someone. Do you want to /disconnect?'
	elif get_lang(update.effective_chat.id) == 'ger':
		text = 'Du hast bereits einen Schlüssel. Bitte warte darauf, dass sich die andere Person mit dir verbindet.'
		text2 = f'Um dich mit deiner Partnerin, deinem Partner zu verbinden, zeig ihr oder ihm bitte den Schlüssel: {key}\nDeine Partnerin oder dein Partner muss dann den Befehl  \"/schluessel\" ausführen und anschließend den Schlüssel eingeben, um sich mit dir zu verbinden.'
		text3 = 'Du bist bereits mit jemandem verbunden. Möchtest du dich trennen? /trenne_dich'
	
	user = get_user(update.effective_chat.id)
	key_list = load_key_list()

	#this checks if the user already is connected, already generated a key before actually
	#creating and passing a key-user-pair 
	#this is to keep the keylist clean an to prefent accidental connecting to several persons
	try:
		for key in key_list:
			#checks if user already created a key
			if key['user_chat_id'] == update.effective_chat.id:
				context.bot.send_message(update.effective_chat.id, text)
				return
		#checks if user already has a partner
		if user['partner_chat_id'] is None:
			context.bot.send_message(chat_id=update.effective_chat.id, text=text2)
			key_list.append({'key': key, 'user_chat_id': update.effective_chat.id})
			write_to_key_list(key_list)
			return
		else:
			context.bot.send_message(update.effective_chat.id, text3)
			return
	except:
		pass
	#fallback if keylist is empty and the forloop fails
	else:
		if user['partner_chat_id'] is None:
			context.bot.send_message(chat_id=update.effective_chat.id, text=text2)
			key_list.append({'key': key, 'user_chat_id': update.effective_chat.id})
			write_to_key_list(key_list)
		else:
			context.bot.send_message(update.effective_chat.id, text3)

def key(update, context):
	#starts the /key conversationhandler
	if get_lang(update.effective_chat.id) == 'eng':
		text = 'Oh! You\'re already connected to someone. Do you want to make a new connection? Then you must /disconnect first.'
		text2 = 'Ah! You want to connect to someone. Good for you! What\'s the key?'
	elif get_lang(update.effective_chat.id) == 'ger':
		text = 'Oh! Du bist schon mit jemandem verbunden. Möchtest du eine neue Verbindung aufbauen? Dann /trenne_dich zu erst von der bestehenden Verbindung.'
		text2 = 'Ah! Du möchtest dich mit jemandem verbinden. Das freut mich für dich! Wie lautet der Schlüssel?'
	
	user = get_user(update.effective_chat.id)
	#checks if user is already connected and ends conversation if so
	if user['partner_chat_id']:
		context.bot.send_message(update.effective_chat.id, text)
		return ConversationHandler.END
	context.bot.send_message(update.effective_chat.id, text2)
	return KEY_ANSWER

def key_answer(update, context):
	if get_lang(update.effective_chat.id) == 'eng':
		text = f'Conragtulations! You are now both connected through the wishingwell. Now go on and fulfill each others wishes and create a happier relationship!'
		text2 = 'Your key wasn\'t found. Please try again.'
		text3 = 'Sorry. I couldn\'t read your key. It must be a number with 6 digits. Please try again.'
	elif get_lang(update.effective_chat.id) == 'ger':
		text = f'Herzlichen Glückwunsch! Ihr seid nun beide durch den Wunschbrunnen mit einander verbunden. Jetzt legt los und macht euch glücklich(er). Viel Spaß beim Wünschen!'
		text2 = 'Dein Schlüssel wurde nicht gefunden. Bitte versuche es noch einmal.'
		text3 = 'Entschuldigung, den Schlüssel konnte ich nicht lesen. Es muss eine sechsstellige Zahl sein. Bitte versuche es noch einmal.'

	key_list = load_key_list()
	try:
		key = int(update.message.text)
		for i in range(len(key_list)):
			#searches the key-user-pair
			if key_list[i]['key'] == key:
				user1 = get_user(key_list[i]['user_chat_id'])
				user1['partner_chat_id'] = update.effective_chat.id
				write_to_user(user1, key_list[i]['user_chat_id'])
				user2 = get_user(update.effective_chat.id)
				user2['partner_chat_id'] = key_list[i]['user_chat_id']
				write_to_user(user2, update.effective_chat.id)
				context.bot.send_message(chat_id=update.effective_chat.id, text=text)
				context.bot.send_message(chat_id=key_list[i]['user_chat_id'], text=text)
				#this removes the key-user-pair and checks if the partner also generated a key
				#if so this key-user-pair is also deleted, then the conversation is ended
				key_list.pop(i)
				for j in range(len(key_list)-1):
					if key_list[j]['user_chat_id'] == update.effective_chat.id:
						key_list.pop(j)
				write_to_key_list(key_list)
				return ConversationHandler.END
		#answer if the key wasn't found
		context.bot.send_message(update.effective_chat.id, text2)
	#fallback if user enters anything but a number
	except ValueError as err:
		context.bot.send_message(update.effective_chat.id, text3)

def disconnect(update, context):
	if get_lang(update.effective_chat.id) == 'eng':
		text = 'You are now disconnected. :('
	elif get_lang(update.effective_chat.id) == 'ger':
		text = 'Du bist nun getrennt. :('
	
	user = get_user(update.effective_chat.id)
	user2 = get_user(user['partner_chat_id'])
	user2_id = user['partner_chat_id']
	user['partner_chat_id'] = None
	user2['partner_chat_id'] = None
	context.bot.send_message(update.effective_chat.id, text)
	write_to_user(user, update.effective_chat.id)
	write_to_user(user2, user2_id)

def grant_a_wish(update, context):
	if get_lang(update.effective_chat.id) == 'eng':
		placeholder = 'This is just a placeholder, because a poll needs at least two options. Please don\'t select me.'
		text1 = 'Here are two wishes from your partner. Choose which one you want to fullfill and select that one.'
		text2 = 'Your partner has only one wish.'
		text3 = 'Your partner has no wish on the wish list. Go and say "I love you" anyway. Unless you don\'t, then don\'t. But if you do, do it. Now!'
		text4 = 'You\'re not yet connected to someone. Do you want to /connect ?'
	elif get_lang(update.effective_chat.id) == 'ger':
		placeholder = 'Das ist ein Platzhalter, da eine Umfrage mindestens 2 Optionen braucht. Bitte wähle mich nicht aus.'
		text1 = 'Hier sind zwei zufällige Wünsche von der Wunschliste deiner Partnerin oder deines Partners. Wähle einen aus und erfülle ihn.'
		text2 = 'Deine Partnerin, dein Partner hat nur einen Wunsch.'
		text3 = 'Deine Partnerin, dein Partner ist wunschlos glücklich. Aber wenn du jetzt zu ihr oder ihm sagst "Ich liebe dich", machst du ihn oder sie bestimmt noch glücklicher. Also los!'
		text4 = 'Du bist noch mit niemandem verbunden. Möchtest du dich mit jemandem /verbinden ?'
	
	current_user = get_user(update.effective_chat.id)
	try:
		partner = get_user(current_user['partner_chat_id'])
		wish_list = partner['wish_list']
		partner_chat_id = current_user['partner_chat_id']
		#a poll with two random wishes of the partner is created
		#if the partner has no wish text3 is send to the user and the function ended
		#if the partner has only wish a placeholder is added
		if len(wish_list) > 1:
			rands = set()
			while len(rands) < 2:
				rands.add(random.randint(0, len(wish_list)-1))
			wishes = []
			for rand in rands:
				wishes.append(wish_list[rand])
			text = text1
		elif len(wish_list) == 1:
			wishes = wish_list[:]
			wishes.append(placeholder)
			text = text2
		else:
			text = text3
			context.bot.send_message(update.effective_chat.id, text)
			return
		message = update.effective_message.reply_poll(text, wishes, type=Poll.REGULAR)
		payload = {
			message.poll.id: {
				"wishes": wishes,
				"wish_list": wish_list,
				"message_id": message.message_id,
				"chat_id": update.effective_chat.id,
				"partner_chat_id": partner_chat_id
			}
		}
		context.bot_data.update(payload)
	#fallback if the user isn't connected to someone
	except TypeError:
		context.bot.send_message(update.effective_chat.id, text4)

def grant_a_wish_answer(update, context):
	if update.poll.is_closed:
		return
	else:
		try:
			quiz_data = context.bot_data[update.poll.id]
		# this means this poll answer update is from an old poll, we can't stop it then
		except KeyError:
			return
		wish_fulfilled = ''

		answer = update.poll.options
		for option in answer:
			if option['voter_count'] == 1:
				wish_fulfilled = option['text']
				wish_list = quiz_data['wish_list']
				if get_lang(quiz_data["chat_id"]) == 'eng':
					text = f'You fulfilled {wish_fulfilled}.'
					text2 = f'For some reason the wish wasn\'t in the wishlist anymore. Or you selected the placeholder.'
				elif get_lang(quiz_data["chat_id"]) == 'ger':
					text = f'Du hast {wish_fulfilled} erfüllt.'
					text2 = f'Aus irgendeinem Grund war der Wunsch nicht mehr in der Wunschliste. Oder du hast den Platzhalter ausgewählt.'
				#check if wish is still there to be removed
				#if not it means was delete by the partner or the placeholder was selected and text2is send to user
				try:
					wish_list.remove(wish_fulfilled)
					partner = get_user(quiz_data['partner_chat_id'])
					partner['wish_list'] = wish_list
					write_to_user(partner, quiz_data['partner_chat_id'])
					context.bot.stop_poll(quiz_data["chat_id"], quiz_data["message_id"])
					context.bot.send_message(quiz_data['chat_id'], text)
				except ValueError:
					context.bot.stop_poll(quiz_data["chat_id"], quiz_data["message_id"])
					context.bot.send_message(quiz_data['chat_id'], text2)

def spent_some_love(update, context):
	#simple function asking for feedback and support
	if get_lang(update.effective_chat.id) == 'eng':
		text = 'Hey there, \nIf you like the bot and improved your relationship, maybe you want to help me out a bit. Every small donation or nice words to wishingwellbot@posteo.de (PayPal) is highly appreciated.'
	elif get_lang(update.effective_chat.id) == 'ger':
		text = 'Hallihallo, \nWenn du den Bot magst und deine Beziehung verbessert hast, magst du mir vielleicht helfen. Jede kleine Spende, Kritik oder nette Worte an wishingwellbot@posteo.de (PayPal) helfen und freuen mich sehr.'
	
	context.bot.send_message(update.effective_chat.id, text)

def help(update, context):
	if get_lang(update.effective_chat.id) == 'eng':
		text = '''Hello, \nYou need some help? No problem! Let me explain the options you have:
		/connect - generates a key to connect to your partner
		/key - enter the key generated by your partner here to connect
		/disconnect - deletes the connection to your partner
		/add_wish - adds a wish to your wishlist
		/show_wishlist - displays your wishlist
		/remove_wish - shows you your wishes in a poll
		/grant_a_wish - shows you two random wishes of your partner
		/spent_some_love - help my maker to make me better
		/cancel - cancels /add_wish or /key
		/help - shows you the available commands
		/settings - let\'s you change the language

		If something is still unclear or you have suggestions to improve the bot, just drop a message to wishingwellbot@posteo.de'''
	elif get_lang(update.effective_chat.id) == 'ger':
		text = '''Hallo, \nDu benötigst Hilfe? Klar, kein Problem! Hier sind noch einmal alle verfügbaren Befehle:
		/verbinden - erzeugt einen Schlüssel, um dich mit einer anderen Person zu verbinden
		/schluessel - gib hier den Schlüssel ein, um die Verbindung herzustellen
		/trenne_dich - löscht die Verbindung zur anderen Person
		/wuensch_dir_was - füge einen Wunsch zu deiner Wunschliste hinzu
		/wunschliste - zeigt dir deine Wunschliste
		/wunsch_loeschen - löscht die Wünsche deiner Wahl von deiner Wunschliste
		/wunsch_erfuellen -  erfülle einen Wunsch der anderen Person, es werden dir zwei zufällig angezeigt
		/spende_liebe - hilf meinem Macher mich besser zu machen
		/cancel - beendet die Funktion /wuensch_dir_was oder /schluessel
		/hilfe - zeigt dir alle verfügbaren Befehle
		/einstellungen - hier kannst du die Sprache des Bots ändern

		Wenn noch immer etwas unklar ist oder du Vorschläge für eine Verbesserung hast, dann schreib mir einfach an wishingwellbot@posteo.de.'''
	
	context.bot.send_message(update.effective_chat.id, text)

def settings(update, context):
	#function to change the language
	#to be exchange by an inlinekeyboardmarkup
	if get_lang(update.effective_chat.id) == 'eng':
		text = 'You want to change the language? Do you want to talk in /english oder in /deutsch with me?'
	elif get_lang(update.effective_chat.id) == 'ger':
		text = 'Du möchtest die Sprache ändern? Möchtest du mit mir in /english oder in /deutsch weiter reden?'
	
	context.bot.send_message(update.effective_chat.id, text)

def get_me(update, context):
	context.bot.send_message(update.effective_chat.id, update.effective_chat.id)

def statistics(update, context):
	users = load_users()
	lonley_user_count = 0
	for user in users:
		if user['partner_chat_id'] == None:
			lonley_user_count += 1
	context.bot.send_message(ADMIN_CHAT_ID, text= 'NutzerInnen insgesamt: ' + str(len(users)) + '\nNutzerInnen ohne Verbindung: ' + str(lonley_user_count))

def weekly_job(context, job):
	jobqueue.run_repeating(statistics, interval= 604800, first= 10)

def main():
	#the first few commands to start the bot and set the user profile
	start_handler = CommandHandler('start', start)
	dispatcher.add_handler(start_handler)

	english_handler = CommandHandler('english', english)
	dispatcher.add_handler(english_handler)

	deutsch_handler = CommandHandler('deutsch', deutsch)
	dispatcher.add_handler(deutsch_handler)

	#english commands
	add_wish_conv_handler = ConversationHandler(entry_points = [CommandHandler('add_wish',  add_wish)],
		states = {ADD_WISH_ANSWER: [MessageHandler(Filters.text & (~Filters.command), add_wish_answer)]},
		fallbacks = [CommandHandler('cancel', cancel), MessageHandler(Filters.command, wrong_input)])
	
	key_conv_handler = ConversationHandler(entry_points = [CommandHandler('key',  key)],
		states = {KEY_ANSWER: [MessageHandler(Filters.text & (~Filters.command), key_answer)]},
		fallbacks = [CommandHandler('cancel', cancel), MessageHandler(Filters.command, wrong_input)])
	
	dispatcher.add_handler(key_conv_handler)
	dispatcher.add_handler(add_wish_conv_handler)

	show_wishlist_handler = CommandHandler('show_wishlist', show_wishlist)
	dispatcher.add_handler(show_wishlist_handler)

	remove_wish_handler = CommandHandler('remove_wish', remove_wish)
	dispatcher.add_handler(remove_wish_handler)

	dispatcher.add_handler(PollAnswerHandler(remove_wish_answer))

	connect_handler = CommandHandler('connect', connect)
	dispatcher.add_handler(connect_handler)

	disconnect_handler = CommandHandler('disconnect', disconnect)
	dispatcher.add_handler(disconnect_handler)

	grant_a_wish_handler = CommandHandler('grant_a_wish', grant_a_wish)
	dispatcher.add_handler(grant_a_wish_handler)

	grant_a_wish_answer_handler = PollHandler(grant_a_wish_answer)
	dispatcher.add_handler(grant_a_wish_answer_handler)

	help_handler = CommandHandler('help', help)
	dispatcher.add_handler(help_handler)

	settings_handler = CommandHandler('settings', settings)
	dispatcher.add_handler(settings_handler)

	spent_some_love_handler = CommandHandler('spent_some_love', spent_some_love)
	dispatcher.add_handler(spent_some_love_handler)

	#german commands
	add_wish_conv_handler = ConversationHandler(entry_points = [CommandHandler('wuensch_dir_was', add_wish)],
		states = {ADD_WISH_ANSWER: [MessageHandler(Filters.text & (~Filters.command), add_wish_answer)]},
		fallbacks = [CommandHandler('cancel', cancel), MessageHandler(Filters.command,wrong_input)])

	key_conv_handler = ConversationHandler(entry_points = [CommandHandler('schluessel', key)],
		states = {KEY_ANSWER: [MessageHandler(Filters.text & (~Filters.command), key_answer)]},
		fallbacks = [CommandHandler('cancel', cancel), MessageHandler(Filters.command,wrong_input)])

	dispatcher.add_handler(key_conv_handler)
	dispatcher.add_handler(add_wish_conv_handler)

	show_wishlist_handler = CommandHandler('wunschliste',show_wishlist)
	dispatcher.add_handler(show_wishlist_handler)

	remove_wish_handler = CommandHandler('wunsch_loeschen',remove_wish)
	dispatcher.add_handler(remove_wish_handler)

	dispatcher.add_handler(PollAnswerHandler(remove_wish_answer))

	connect_handler = CommandHandler('verbinden',connect)
	dispatcher.add_handler(connect_handler)

	disconnect_handler = CommandHandler('trenne_dich',disconnect)
	dispatcher.add_handler(disconnect_handler)

	grant_a_wish_handler = CommandHandler('wunsch_erfuellen',grant_a_wish)
	dispatcher.add_handler(grant_a_wish_handler)

	grant_a_wish_answer_handler = PollHandler(grant_a_wish_answer)
	dispatcher.add_handler(grant_a_wish_answer_handler)

	help_handler = CommandHandler('hilfe', help)
	dispatcher.add_handler(help_handler)

	settings_handler = CommandHandler('einstellungen', settings)
	dispatcher.add_handler(settings_handler)

	spent_some_love_handler = CommandHandler('spende_liebe',spent_some_love)
	dispatcher.add_handler(spent_some_love_handler)

	#jobqueue sending me statistics every week
	statistics_handler = CommandHandler('statistics', statistics, pass_job_queue=True)
	dispatcher.add_handler(statistics_handler)

	updater.start_polling()

	updater.idle()

if __name__ == '__main__':
	main()
